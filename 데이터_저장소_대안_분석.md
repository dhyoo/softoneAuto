# 데이터 저장소 대안 분석

## 현재 상황
- **현재 사용**: JSON 파일 (Gson)
- **문제점**: 파일 손상 시 복구 어려움, 대용량 데이터 처리 비효율
- **요구사항**: 폐쇄망 환경, 파일 기반, 설치 불필요

---

## 대안 옵션 비교

### 1. **SQLite** ⭐⭐⭐⭐⭐ (가장 추천)

#### 장점
- ✅ **파일 기반**: 단일 파일로 모든 데이터 저장
- ✅ **ACID 트랜잭션**: 데이터 무결성 보장
- ✅ **손상 복구**: 내장 복구 메커니즘 (`PRAGMA integrity_check`)
- ✅ **성능**: 인덱싱, 쿼리 최적화
- ✅ **표준 SQL**: 복잡한 쿼리 가능
- ✅ **경량**: 라이브러리 크기 작음 (~1MB)
- ✅ **Java 지원**: JDBC 드라이버 제공
- ✅ **백업 용이**: 파일 복사만으로 백업

#### 단점
- ❌ **의존성 추가**: SQLite JDBC 드라이버 필요
- ❌ **학습 곡선**: SQL 쿼리 작성 필요
- ❌ **마이그레이션**: 기존 JSON 데이터 변환 필요

#### 구현 복잡도
- **중간**: Repository 패턴으로 추상화 가능
- **마이그레이션**: JSON → SQLite 변환 스크립트 필요

#### 추천도: ⭐⭐⭐⭐⭐
**가장 실용적이고 안정적인 선택**

---

### 2. **H2 Database** ⭐⭐⭐⭐

#### 장점
- ✅ **순수 Java**: 외부 의존성 없음
- ✅ **인메모리/파일 모드**: 유연한 사용
- ✅ **SQL 지원**: 표준 SQL 사용
- ✅ **경량**: 작은 라이브러리
- ✅ **내장**: JAR에 포함 가능

#### 단점
- ❌ **성능**: SQLite보다 약간 느림
- ❌ **복구 기능**: SQLite만큼 강력하지 않음
- ❌ **마이그레이션**: 기존 데이터 변환 필요

#### 구현 복잡도
- **중간**: JDBC 사용, Repository 패턴 적용

#### 추천도: ⭐⭐⭐⭐
**순수 Java 환경에 적합**

---

### 3. **Apache Derby** ⭐⭐⭐

#### 장점
- ✅ **순수 Java**: 외부 의존성 없음
- ✅ **SQL 지원**: 표준 SQL
- ✅ **임베디드 모드**: 애플리케이션에 내장

#### 단점
- ❌ **성능**: SQLite/H2보다 느림
- ❌ **라이브러리 크기**: 상대적으로 큼
- ❌ **복구 기능**: 제한적

#### 추천도: ⭐⭐⭐
**Java 전용 환경에 적합하나 성능 이슈**

---

### 4. **MessagePack** ⭐⭐⭐

#### 장점
- ✅ **바이너리 형식**: JSON보다 작고 빠름
- ✅ **손상 저항**: 구조가 단순하여 부분 복구 가능
- ✅ **호환성**: JSON과 유사한 구조

#### 단점
- ❌ **가독성**: 바이너리라 직접 확인 불가
- ❌ **복구**: 여전히 파일 손상 시 문제
- ❌ **의존성**: 라이브러리 추가 필요

#### 추천도: ⭐⭐⭐
**성능이 중요한 경우 고려**

---

### 5. **Protocol Buffers (protobuf)** ⭐⭐

#### 장점
- ✅ **효율성**: 매우 작고 빠름
- ✅ **타입 안전성**: 스키마 기반
- ✅ **버전 호환성**: 스키마 진화 지원

#### 단점
- ❌ **복잡도**: 스키마 정의 필요
- ❌ **가독성**: 바이너리 형식
- ❌ **학습 곡선**: 높음
- ❌ **손상 복구**: 어려움

#### 추천도: ⭐⭐
**복잡도 대비 이점이 적음**

---

### 6. **YAML** ⭐⭐

#### 장점
- ✅ **가독성**: 사람이 읽기 쉬움
- ✅ **구조화**: JSON보다 표현력 좋음
- ✅ **의존성**: 작은 라이브러리

#### 단점
- ❌ **성능**: JSON보다 느림
- ❌ **손상 복구**: JSON과 유사한 문제
- ❌ **파싱 복잡도**: 들여쓰기 기반이라 오류 가능

#### 추천도: ⭐⭐
**설정 파일용으로는 좋으나 데이터 저장소로는 부적합**

---

### 7. **CSV** ⭐

#### 장점
- ✅ **단순함**: 구현이 매우 쉬움
- ✅ **가독성**: Excel에서 바로 열기 가능
- ✅ **호환성**: 모든 시스템에서 지원

#### 단점
- ❌ **구조 제한**: 중첩 구조 표현 어려움
- ❌ **타입 정보**: 문자열로만 저장
- ❌ **관계 표현**: 어려움
- ❌ **손상 복구**: 라인 단위로만 가능

#### 추천도: ⭐
**단순한 데이터에만 적합**

---

## 종합 비교표

| 옵션 | 손상 복구 | 성능 | 안정성 | 구현 난이도 | 추천도 |
|------|----------|------|--------|------------|--------|
| **SQLite** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **H2** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **Derby** | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **MessagePack** | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |
| **Protobuf** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ |
| **YAML** | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ |
| **CSV** | ⭐ | ⭐⭐ | ⭐ | ⭐ | ⭐ |

---

## 추천 방안

### 🥇 **1순위: SQLite**
**이유:**
- 파일 손상 시 자동 복구 기능 (`PRAGMA integrity_check`, `PRAGMA quick_check`)
- ACID 트랜잭션으로 데이터 무결성 보장
- 성능 우수 (인덱싱, 쿼리 최적화)
- 표준 SQL로 복잡한 쿼리 가능
- 파일 기반이라 백업/이동 용이

**구현 예시:**
```java
// SQLite JDBC 드라이버 추가 필요
dependencies {
    implementation 'org.xerial:sqlite-jdbc:3.44.1.0'
}

// Repository 패턴으로 추상화
public class SqliteRepository<T> {
    private Connection connection;
    
    public void save(T entity) {
        // 트랜잭션으로 안전하게 저장
    }
    
    public List<T> findAll() {
        // 손상 감지 및 자동 복구
        checkIntegrity();
        // 쿼리 실행
    }
}
```

### 🥈 **2순위: H2 Database**
**이유:**
- 순수 Java로 외부 의존성 없음
- 인메모리 모드로 빠른 테스트 가능
- 파일 모드로 영구 저장 가능

---

## 마이그레이션 전략

### JSON → SQLite 전환 시나리오

1. **단계적 전환**
   - 기존 JSON 파일 읽기
   - SQLite DB 생성 및 스키마 정의
   - 데이터 마이그레이션 스크립트 실행
   - 양쪽 모두 지원하는 하이브리드 기간 운영

2. **데이터 검증**
   - JSON 데이터와 SQLite 데이터 비교
   - 무결성 검증
   - 사용자 확인 후 JSON 제거

3. **롤백 계획**
   - SQLite → JSON 역변환 스크립트 준비
   - 문제 발생 시 즉시 롤백 가능

---

## 결론

**SQLite를 강력 추천합니다.**

이유:
1. ✅ **손상 복구**: 내장 복구 메커니즘으로 JSON보다 훨씬 안전
2. ✅ **데이터 무결성**: ACID 트랜잭션으로 부분 손상 방지
3. ✅ **성능**: 인덱싱과 쿼리 최적화로 대용량 데이터 처리 가능
4. ✅ **표준화**: SQL 표준으로 유지보수 용이
5. ✅ **파일 기반**: 폐쇄망 환경에 적합

**현재 JSON의 문제점(손상 시 복구 어려움)을 근본적으로 해결할 수 있습니다.**

